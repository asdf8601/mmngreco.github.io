---
title: "Title"
date: 2024-03-30
draft: false
categories: ["programming" ]
labels: ["spanish", "python", "pipx", "conda", "macos" ]
---

## Contexto

Soy un gran admirador de `pipx`, pero por alguna raz√≥n, no funciona tan bien en
macOS como en Linux.

Dada la funcionalidad √∫til que ofrece, he tenido que abandonar el uso de `brew`
para su instalaci√≥n y recurrir a `conda` en su lugar. Esto me permite controlar
la versi√≥n de Python que `pipx` usa. De lo contrario, instalar√≠a la √∫ltima
versi√≥n de Python, la cual algunos CLIs no soportan (como `duckdb`).

Sin embargo, la situaci√≥n no se limita a esto. Recientemente, me enfrent√© al
siguiente desaf√≠o:


```bash
$ pipx install visidata
  installed package visidata 3.0.2, installed using Python 3.11.5
  These apps are now globally available
    - vd
    - vd2to3.vdx
    - visidata
  These manual pages are now globally available
    - man1/vd.1
    - man1/visidata.1
done! ‚ú® üåü ‚ú®
$ vd
zsh: /Users/mgreco/.local/bin/vd: bad interpreter: /Users/mgreco/Library/Application: no such file or directory
```

Ya me siento bastante agotado de seguir creando soluciones provisionales para
esto, siendo que deber√≠a funcionar de inmediato (supongo que alguna
implementaci√≥n inusual de macOS, impide que funcione correctamente).

## Solucion

Lanc√© mi propia soluci√≥n s√∫per simple que utiliza lo que ya tengo instalado en
mi sistema: `conda` y `pip`.

La idea es sencilla: replicar la funcionalidad de `pipx install`, pero usando
conda. Esto proporciona control sobre la versi√≥n de Python que deseas usar para
cada entorno.

Lo primero que hice fue definir c√≥mo quiero usarlo, que es f√°cil si ya conoces
`pipx`. Aqu√≠ te lo detallo:

```bash
cx install black
cx install black -p 3.11
cx install git+https://github.com/psf/black
```

En t√©rminos m√°s precisos, los pasos a seguir son los siguientes:

1. Crear un entorno utilizando la versi√≥n deseada de Python.
1. Instalar el paquete requerido en el entorno creado.
1. Realizar la creaci√≥n de un enlace simb√≥lico a la Interfaz de L√≠nea de
   Comandos (CLI) en `~/.local/bin`.


## Iteracion 0

Lo que traducido de manera literal en bash, resultar√≠a en algo similar a esto:

```bash
dep=$1
conda create -p ~/.cx/venvs/$dep/ python=3.11 -y
~/.cx/venvs/$dep/bin/pip install $dep
ln -s ~/.cx/venvs/$dep/bin/$dep ~/.local/bin/$dep
```


Encontraste r√°pidamente varios problemas con esta implementaci√≥n. Algunos de
estos son:

1. Usar `dep` como nombre del entorno es poco com√∫n. Dep podr√≠a ser una URL.
2. Necesitas parametrizar la versi√≥n de python.
3. ¬øQu√© sucede si el binario no tiene el mismo nombre que el paquete?

Por tanto, decidiste cambiar a un script en python que te da un control m√°s
detallado de lo que deseas hacer.

## Iteracion 1


```python
import subprocess
import argparse

parser = argparse.ArgumentParser()
parser.add_argument("dep", help="can be a URL or a package name")
parser.add_argument("-p", "--pyver", help="python version to use", default="3.11")

args = parser.parse_args()

dep = args.dep
pyver = args.pyver


# extract name from dep
name = dep.split('/')[-1].split('.')[0]

conda_cmd = f"conda create -p ~/.cx/venvs/{name} python={pyver} -y"
pip_cmd = f"~/.cx/venvs/{name}/bin/pip install -q {dep} "

subprocess.call(conda_cmd, shell=True)
subprocess.call(pip_cmd, shell=True)
```

Esta solucion ya hace lo que quiero (salvo el symlink), solo falta incluir el
symlink y alguna otras mejoras.


## Iteracion 2


```python
import subprocess
import argparse

parser = argparse.ArgumentParser()
parser.add_argument("dep", help="can be a URL or a package name")
parser.add_argument("-p", "--pyver", help="python version to use", default="3.11")

args = parser.parse_args()

dep = args.dep
pyver = args.pyver


# extract name from dep
name = dep.split('/')[-1].split('.')[0]
print(name)

conda_cmd = f"conda create -p ~/.cx/venvs/{name} python={pyver} -y -q > /dev/null"
pip_cmd = f"~/.cx/venvs/{name}/bin/pip install -q {dep} "

from pathlib import Path

subprocess.call(conda_cmd, shell=True)
pre_binaries = set(Path(f"~/.cx/venvs/{name}/bin/").glob('*'))
subprocess.call(pip_cmd, shell=True)
post_binaries = set(Path(f"~/.cx/venvs/{name}/bin/").glob('*'))

new_binaries = post_binaries - pre_binaries
print(new_binaries)
```


Determinar qu√© binarios incluir en `~/.local/bin` es un poco complicado, pero
funciona bien para lo que necesito y tiene espacio para mejorar.

El problema con esta soluci√≥n es que la salida de `new_binaries` es un conjunto
vac√≠o. Sucede que MacOS devuelve `False` en
`Path(f"~/.cx/venvs/{name}/bin/").exists()`, pero si haces
`Path(f"~/.cx/venvs/{name}/bin/").expanduser().exists()`, devuelve `True`.

Por lo tanto, una vez resuelto el problema, ya tengo `black` y `blackd` en
`new_binaries`.

## Iteracion 3


```python
import subprocess
import argparse
from pathlib import Path

parser = argparse.ArgumentParser()
parser.add_argument(
    "cmd",
    help="can be a URL or a package name",
    default="install",
    choices=["install", "inject", "run"],
)
parser.add_argument("dep", help="can be a URL or a package name")
parser.add_argument("-p", "--pyver", help="python version to use", default="3.11")
parser.add_argument("-f", "--force", help="Force", action="store_true")
parser.add_argument("-v", "--verbose", help="Verbose", action="store_true")
args = parser.parse_args()

dep = args.dep
pyver = args.pyver
force = args.force
cmd = args.cmd
verbose = args.verbose

# extract vname from dep
vname = dep.split("/")[-1].split(".")[0]

# define variables
VENV = Path(f"~/.cx/venvs/{vname}").expanduser()
BIN = Path(f"~/.cx/venvs/{vname}/bin").expanduser()
PIP = Path(f"{BIN}/pip").expanduser()

if verbose:
    print(f"{VENV = }")
    print(f"{BIN = }")
    print(f"{PIP = }")

if cmd != "install":
    raise NotImplementedError

# create venv
venv_cmd = f"conda create -p {VENV} python={pyver} -y -q > /dev/null"

if verbose:
    print(f"{venv_cmd = }")

subprocess.call(venv_cmd, shell=True)
pre_binaries = set(BIN.glob("*"))

# install dep
pip_cmd = f"{PIP} install -q {dep}"

if verbose:
    print(f"{pip_cmd = }")

subprocess.call(pip_cmd, shell=True)
post_binaries = set(BIN.glob("*"))

# find new binaries
new_binaries = post_binaries - pre_binaries

# create symlink in ~/.local/bin
f = "-f" if force else ""
for p in new_binaries:
    link_cmd = f"ln {f} -s {p} ~/.local/bin"

    if verbose:
        print(f"{link_cmd = }")

    subprocess.call(link_cmd, shell=True)
```


Esta es la soluci√≥n final.


Repo: https://github.com/mmngreco/cx


## Demo


{{< youtube faE4_IDbcP0 >}}
